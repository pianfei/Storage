
接“因此，我们直接反驳了流行的观点，即此类协议必然是不切实际的。”

我们对 Cachin 等人提出的最先进的异步原子广播协议进行了重大的效率改进[15]，该协议要求每个节点为每个提交的事务传输 O(N^2) 位，这大大限制了其吞吐量，除非网络规模非常小。这种低效率有两个根本原因。第一个原因是各方之间的冗余工作。然而，消除冗余的天真尝试会损害公平性，并允许有针对性的审查攻击。我们发明了一种新颖的解决方案，通过使用阈值公钥加密来防止这些攻击，从而克服了这个问题。第二个原因是使用了异步公共子集（ACS）子组件的次优实例化。我们展示了如何通过结合现有但被忽视的技术来有效地实例化 ACS：使用纠删码的高效可靠广播 [18]，以及多方计算文献中从 ACS 到可靠广播的规约 [9]。

HoneyBadgerBFT 的设计针对类似加密货币的部署场景进行了优化，其中网络带宽是稀缺资源，但计算相对充足。这使我们能够利用密码学构建块（特别是阈值公钥加密），这些构建块在经典的容错数据库环境中被认为是过于昂贵的，在经典环境中，主要目标是即使在争用情况下也能最大限度地减少响应时间。

在异步网络中，消息最终会被传递，但不做其他时序假设。与现有的弱同步协议（参数调整可能很麻烦）不同，HoneyBadgerBFT 并不关心。无论网络条件如何波动，HoneyBadgerBFT 的吞吐量始终紧密跟踪网络的可用带宽。不精确地说，只要消息最终能够送达，HoneyBadgerBFT 最终就会取得进展；此外，消息一送达，它就会取得进展。

我们正式证明了我们的 HoneyBadgerBFT 协议的安全性和活性，并通过实验表明，即使在乐观情况下，它也提供了比经典 PBFT 协议 [20] 更好的吞吐量。

实现和大规模实验。 我们提供了 HoneyBadgerBFT 的完整实现，我们将在不久的将来将其作为免费的开源软件发布。1 我们展示了来自亚马逊 AWS 部署的实验结果，该部署有 100 多个节点分布在 5 大洲。为了证明其多功能性和健壮性，我们还在 Tor 匿名中继网络上部署了 HoneyBadgerBFT，而无需更改任何参数，并展示了吞吐量和延迟结果。

在众多可能的应用中，我们重点介绍了银行、金融机构和完全去中心化加密货币倡导者所追求的两个可能的部署场景。

联盟加密货币。 比特币等去中心化加密货币的成功激发了银行和金融机构以新的视角审视其交易处理和结算基础设施。“联盟加密货币”是一个经常被引用的愿景 [24,25,47]，其中金融机构集团共同参与拜占庭协议，以允许快速和稳健地结算交易。人们热情高涨，认为这种方法将简化当今缓慢而笨拙的银行间结算基础设施。因此，一些新的开源项目旨在为此设置构建合适的 BFT 协议，例如 IBM 的开放区块链和 Hyperledger 项目 [40]。

联盟加密货币将需要一个部署在广域网上的 BFT 协议，可能涉及数百到数千个共识节点。在这种情况下，可以轻松控制注册，从而预先知道共识节点集——通常称为“许可”区块链。显然，HoneyBadgerBFT 是此类联盟加密货币中的自然选择。

适用于非许可区块链。 相比之下，比特币和以太坊等去中心化加密货币选择“非许可”区块链，其中注册对任何人开放，节点可以动态且频繁地加入和离开。为了在这种环境中实现安全性，已知的共识协议依赖于工作量证明来击败 Sybil 攻击，并在吞吐量和延迟方面付出了巨大的代价，例如，比特币每 ~10 分钟提交一次交易，即使当前区块大小最大化，其吞吐量也限制为 7 笔/秒。最近的一些工作提出了一个有希望的想法，即利用较慢的外部区块链（如比特币）或涉及基础货币本身的经济“权益证明”假设 [32,32,35,37] 来引导更快的 BFT 协议，方法是在每个不同的时期选择一个随机委员会来执行 BFT。这些方法有望实现两全其美，在开放注册、去中心化网络中实现安全性，以及与经典 BFT 协议相匹配的吞吐量和响应时间。在这里，HoneyBadgerBFT 也是一个自然的选择，因为随机选择的委员会可以在地理上是异构的。

2.1 强健的BFT协议

虽然Paxos [36]、Raft [45]和许多其他知名协议能够容忍崩溃故障，但拜占庭容错协议（BFT）自PBFT [20]以来，甚至能够容忍任意（例如，恶意）损坏的节点。许多后续协议通过乐观执行提供了改进的性能，当没有故障、客户端竞争不激烈且网络表现良好时，这些协议能够提供卓越的性能，并在其他情况下至少保证一定的进展 [2,5,33,39,51]。

一般而言，BFT系统在延迟和CPU成为瓶颈的部署场景中进行评估 [49]，因此最有效的协议通过减少轮数和最小化昂贵的加密操作来提高性能。

Clement等人 [22] 开创了一条近期的研究路线 [4,6,10,21,22,50]，主张改进最坏情况下的性能，即使这在乐观情况下会牺牲性能，也要在系统受攻击时提供服务质量保证。然而，尽管这一系列的“强健BFT”协议能够优雅地容忍被破坏的节点，它们仍然依赖于对底层网络的时间假设。我们的工作进一步推进了这种方法，即使在完全异步的网络中也能保证良好的吞吐量。

2.2 随机一致性

对于大多数任务，确定性的异步协议是不可能的 [27]。虽然绝大多数实际的BFT协议通过做出时间假设来避开这一不可能性结果，但随机性（尤其是加密技术）提供了另一条途径。事实上，我们知道有多种任务的异步BFT协议，如二元一致性（ABA）、可靠广播（RBC）等 [13,15,16]。

我们的工作与SINTRA [17] 最为相关，后者是基于Cachin等人（CKPS01）提出的异步原子广播协议的系统实现 [15]。该协议包括从原子广播（ABC）到公共子集一致性（ACS）的简化，以及从ACS到多值验证一致性（MVBA）的简化。

我们贡献的关键创新是从ABC到ACS的新颖简化，通过批处理提供更好的效率（提高了O(N)倍），同时使用门限加密来保持审查抵抗力（见第4.4节）。我们还通过从文献中精选子组件的改进实例来获得更好的效率。特别是，我们通过使用替代的ACS [9] 和高效的RBC [18] 避开了昂贵的MVBA原语，如第4.4节所述。

表1总结了HoneyBadgerBFT与其他几种原子广播协议的渐近性能。这里“通信复杂度”表示每个已提交交易的预期通信复杂度（即总传输字节数）。由于PBFT依赖于弱同步假设，因此在异步网络中可能完全无法进展。协议KS02 [34]和RC05 [46]是乐观的，回退到基于MVBA的昂贵恢复模式。如前所述，Cachin等人（CKPS01）[15] 的协议可以通过更高效的ACS构造 [9,18] 进行改进。通过我们新颖的简化，我们还获得了另一个O(N)的改进。

最后，King和Saia [30,31]最近开发了通过在稀疏图上路由通信以实现低于二次消息数量的一致性协议。然而，将这些结果扩展到异步环境仍然是一个未解决的问题。

3. 异步与弱同步网络模型之间的差距

几乎所有现代的BFT协议都依赖于时间假设（如部分或弱同步性）来保证活性。纯异步的BFT协议近年来受到的关注明显较少。考虑以下论点，如果成立，将证明这一狭窄焦点的合理性：

[X] 弱同步假设是不可避免的，因为在任何违反这些假设的网络中，即使是异步协议也会提供不可接受的性能。

在本节中，我们提出了两个反驳上述前提的反论。首先，我们展示了异步和弱同步网络模型之间的理论分离。具体来说，我们构建了一个对抗性的网络调度器，违反了PBFT的弱同步假设（并且确实导致其失败），但在这种情况下，任何纯异步协议（如HoneyBadgerBFT）都能取得良好的进展。其次，我们做出了一个实际观察：即使它们的假设得到满足，弱同步协议在网络分区恢复后仍然恢复缓慢，而异步协议只要消息被传递就会立即进展。

3.1 多种形式的时间假设

在继续之前，我们回顾各种标准的时间假设形式。在异步网络中，对手可以以任何顺序和任何时间传递消息，但仍然必须最终传递在正确节点之间发送的每条消息。异步网络中的节点实际上不需要“实时时钟”，只能基于它们接收消息的顺序采取行动。

著名的FLP [27] 结果排除了原子广播和许多其他任务的确定性异步协议的可能性。因此，确定性协议必须做出一些更强的时间假设。一种方便（但非常强）的网络假设是同步性：∆-同步网络保证每条发送的消息在最多∆的延迟后被传递（其中∆是真实时间的度量）。

较弱的时间假设有几种形式。在未知∆模型中，协议无法将延迟界限用作参数。或者，在最终同步模型中，消息延迟界限∆仅在某些（未知的）时刻之后得到保证，这个时刻被称为“全局稳定时间”。总体而言，这两种模型被称为部分同步 [26]。另一种变化是弱同步 [26]，其中延迟界限是时变的，但最终不会增长得超过时间的多项式函数 [20]。

在可行性方面，上述是等价的——在一种设置中成功的协议可以系统地适应另一种设置。然而，在具体性能方面，调整弱同步意味着逐渐增加超时参数（例如，通过“指数回退”策略）。如我们稍后所示，这在从瞬时网络分区中恢复时会导致延迟。

协议通常以超时事件的形式表现出这些假设。例如，如果各方检测到在某个时间间隔内没有进展，则采取纠正措施，如选举新领导者。异步协议不依赖于计时器，只要消息被传递，就会继续进展，无论实际的时钟时间如何。

计算异步网络中的轮数

虽然最终交付的保证与“实时时间”的概念是分离的，但仍然希望对异步协议的运行时间进行表征。标准的方法（例如，Canetti和Rabin [19] 解释的方式）是让对手为每条消息分配一个虚拟的轮数，条件是每条正确节点之间的(r−1)-消息必须在发送任何(r+1)-消息之前被传递。

3.2 弱同步性失效时

我们现在继续描述为什么在网络条件具有对抗性（或不可预测）的情况下，弱同步BFT协议可能会失败（或遭受性能下降）。这解释了为什么这些协议不适合第1节中描述的面向加密货币的应用场景。

阻碍PBFT的网络调度器

我们使用Practical Byzantine Fault Tolerance (PBFT) [20]，经典的基于领导者的BFT协议，作为一个代表性的例子来描述对抗性的网络调度器如何导致一类基于领导者的BFT协议 [4,6,10,22,33,50] 停滞不前。

在任何给定时间，指定的领导者负责提出下一批交易。如果没有进展，可能是因为领导者故障或网络停滞，节点们将尝试选举新的领导者。PBFT协议关键依赖于弱同步网络来保证活性。我们构建了一个对抗性调度器，违反了这一假设，并确实阻止PBFT取得任何进展，但HoneyBadgerBFT（实际上任何异步协议）在这种情况下表现良好。基于时间假设的协议在这些假设被违反时失败并不令人惊讶；然而，展示一个明确的攻击有助于激励我们异步构建的动机。

我们的调度器背后的直觉很简单。首先，我们假设一个单一节点已经崩溃。然后，当一个正确节点是领导者时，网络会延迟消息，阻止进展并导致轮转顺序中的下一个节点成为新的领导者。当崩溃的节点轮到成为领导者时，调度器立即修复网络分区，并在诚实节点之间迅速传递消息；然而，由于领导者已经崩溃，这里也没有进展。

这种攻击违反了弱同步假设，因为它必须在每个周期中延迟消息越来越长，因为PBFT在每次领导者选举失败后都会扩大其超时间隔。另一方面，它也提供了越来越长的同步期。然而，由于这些同步期发生在不方便的时间，PBFT无法利用它们。展望未来，HoneyBadgerBFT，实际上任何异步协议，都能在这些偶发的同步期内取得进展。

为了确认我们的分析，我们将这个恶意调度器实现为一个代理，拦截并延迟所有视图变更消息到新领导者，并在一个1200行的PBFT Python实现上进行了测试。我们观察到的结果和消息日志与上述分析一致；我们的副本陷入了一个永不成功的视图变更请求循环。在附录A中，我们对PBFT进行了完整的描述，并解释了它在这种攻击下的行为。

从网络分区中缓慢恢复

即使弱同步假设最终得到满足，依赖于它的协议在从瞬时网络分区中恢复时也可能会很慢。考虑以下场景，这只是上述攻击的一个有限前缀：一个节点崩溃，网络暂时分区持续2D∆。我们的调度器在崩溃节点轮到成为领导者时恰好修复网络分区。由于此时的超时间隔现在是2D+1∆，即使在此间隔内网络是同步的，协议也必须等待另一个2D+1∆的间隔才能开始选举新的领导者。

健壮性与响应性的权衡

上述观察到的行为并非PBFT特有，而是依赖于超时来应对崩溃的协议所固有的基本特性。无论协议的变体如何，实践者都必须根据某些权衡来调整他们的超时策略。在一个极端（最终同步性），实践者对网络延迟∆做出具体估计。如果估计值太低，系统可能根本不会取得进展；如果太高，则无法利用可用带宽。在另一个极端（弱同步性），实践者避免指定任何绝对延迟，但仍必须选择一个“增益”，这影响系统跟踪变化条件的速度。异步协议避免了调整这些参数的需要。

4. HoneyBadgerBFT协议

在本节中，我们介绍HoneyBadgerBFT，这是第一个在异步环境中实现最优渐近效率的异步原子广播协议。

4.1 问题定义：原子广播

我们首先定义我们的网络模型和原子广播问题。我们的设置涉及一个由N个指定节点组成的网络，这些节点具有不同的知名身份（P0到PN−1）。这些节点接收交易作为输入，目标是就这些交易的顺序达成共同的一致意见。我们的模型特别匹配“许可区块链”的部署场景，在这种场景中，交易可以由任意客户端提交，但负责执行协议的节点是固定的。

原子广播原语允许我们抽象出任何应用特定的细节，例如如何解释交易（例如，为了防止重放攻击，应用可能定义一个交易包括签名和序列号）。就我们的目的而言，交易只是唯一的字符串。实际上，客户端会生成交易并将其发送给所有节点，并在收集到多数节点的签名后将其视为已提交。为了简化我们的表述，我们不显式地建模客户端，而是假设交易由对手选择并作为输入提供给节点。同样，一旦节点输出交易，交易就被视为已提交。

我们的系统模型做出以下假设：

• （纯异步网络） 我们假设每对节点之间连接着一个可靠的认证点对点信道，不会丢失消息。交付计划完全由对手决定，但每条在正确节点之间发送的消息最终必须被传递。我们将关注基于异步轮数（如第2节所述）来表征协议的运行时间。由于网络可能以任意延迟排队消息，我们还假设节点具有无限缓冲区，并能够处理它们接收的所有消息。

• （静态拜占庭故障） 对手可以完全控制最多f个故障节点，其中f是协议参数。注意，对于这种设置中的广播协议，3f +1 ≤ N（我们的协议实现了这一点）是下限。

• （可信设置） 为了便于表述，我们假设节点可以在初始的协议特定设置阶段与可信的分发方互动，我们将使用这一阶段来建立公钥和秘密共享。注意，在实际部署中，如果没有实际的可信方，那么可以改用分布式密钥生成协议（参见Boldyreva [11]）。我们所知的所有分布式密钥生成协议都依赖于时间假设；幸运的是，这些假设只需在设置期间成立。

2. 可靠信道可以在不可靠信道上模拟

通过重新发送传输，可以在不可靠信道上模拟可靠信道，但以牺牲一些效率为代价。

定义1。 一个原子广播协议必须满足以下属性，这些属性应在异步网络中并且面对任意对手时，以高概率（作为安全参数λ的函数1−negl(λ)）成立：

• （一致性） 如果任何正确节点输出一个交易tx，则每个正确节点都输出tx。

• （全序） 如果一个正确节点已经输出了交易序列<tx0, tx1, ..., txj>，另一个正确节点已经输出了交易序列<tx0', tx1', ..., tx'_j'>，那么对于i ≤ min(j, j')，有txi = txi'。

• （审查抵抗力） 如果一个交易tx被输入到N−f个正确节点，那么最终每个正确节点都会输出它。

审查抵抗力属性是一种活性属性，防止对手阻止甚至单个交易的提交。这个属性在其他名字下也被提及，例如Cachin等人 [15]称之为“公平性”，但我们更喜欢这个更具描述性的短语。

性能指标。 我们主要关注分析我们的原子广播协议的效率和交易延迟。

• （效率） 假设每个诚实节点的输入缓冲区足够满，即Ω(poly(N, λ))。那么效率是每个节点在所有已提交交易上的预期通信成本的摊销值。

由于每个节点必须输出每个交易，O(1)的效率（我们的协议实现了这一点）在渐近上是最优的。上述效率定义假设网络负载，反映了我们的主要目标：在充分利用网络可用带宽的同时维持高吞吐量。由于我们通过批处理实现了良好的吞吐量，我们的系统在需求低迷期间，当交易不频繁到达时，每个已提交交易使用更多的带宽。如果我们的目标是最小化成本（例如，基于用量的计费），则无需此限定的更强定义将是适当的。

实际上，网络链接具有有限的容量，如果提交的交易超过网络可处理的量，确认时间的保证在一般情况下无法成立。因此，我们下面将交易延迟相对于在问题交易之前输入的交易数量进行定义。有限的交易延迟意味着审查抵抗力。

• （交易延迟） 假设对手将一个交易tx作为输入传递给N−f个正确节点。设T为“积压”，即任何正确节点之前输入的总交易数量与已提交交易数量之间的差异。那么交易延迟是在tx被每个正确节点输出之前的异步轮数的预期值，作为T的函数。

4.2 概述与直觉

在HoneyBadgerBFT中，节点接收交易作为输入并将其存储在（无限的）缓冲区中。协议在历元中进行，每个历元结束后，一批新的交易被追加到已提交的日志中。在每个历元开始时，节点选择其缓冲区中的一部分交易子集（通过我们稍后将定义的策略），并将其作为输入提供给一个随机一致性协议的实例。在一致性协议结束时，选择该历元的最终交易集。

在高层次上，我们的方法类似于现有的异步原子广播协议，特别是Cachin等人 [15]，这是一个大规模交易处理系统（SINTRA）的基础。如我们一样，Cachin的协议围绕异步公共子集（ACS）原语展开。粗略地说，ACS原语允许每个节点提出一个值，并保证每个节点输出一个包含至少N−2f个正确节点输入值的共同向量。从这个原语构建原子广播是微不足道的——每个节点只需从其队列前端提出一部分交易，并输出在同意的向量中的元素的并集。

然而，有两个重要的挑战。

挑战1：实现审查抵抗力。 ACS的成本直接取决于每个节点提出的交易集的大小。由于输出向量包含至少N−f个这样的集，因此通过确保节点提出的交易集大多不重叠，从而以相同的成本在一个批次中提交更多独特的交易，可以提高整体效率。因此，我们的协议中的每个节点不是简单地从其缓冲区中选择第一个元素，而是提出一个随机选择的样本，使得每个交易平均只被一个节点提出。

然而，若天真地实施这一优化，将会破坏审查抵抗力，因为ACS原语允许对手选择最终包含哪些节点的提案。对手可以选择性地审查交易，排除提出它的节点。我们通过使用门限加密避免了这一陷阱，这防止了对手在达成一致之前了解哪些节点提出了哪些交易。完整的协议将在第4.3节中描述。

挑战2：实际吞吐量。 尽管理论上已知异步ACS和原子广播是可行的 [9,15,17]，它们的实际性能尚不明朗。据我们所知，唯一实施ACS的其他工作是Cachin和Portiz [17]，他们展示了在广域网络上可以达到0.4 tx/sec的吞吐量。因此，一个有趣的问题是，这些协议是否能在实际中达到高吞吐量。

在本文中，我们展示了通过仔细选择一系列子组件，我们可以高效地实例化ACS并在渐近和实际中达到更高的吞吐量。值得注意的是，我们将ACS的渐近成本（每节点）从O(N²)（如Cachin等人 [15,17]）改进为O(1)。由于我们选择的组件尚未被一起呈现（据我们所知），我们在第4.4节中提供了整个构建的自包含描述。

模块化协议组合

我们现在准备正式展示我们的构建。在此之前，我们对我们的展示风格做出一项说明。我们以模块化的风格定义我们的协议，其中每个协议可能运行多个其他（子）协议的实例。外部协议可以向子协议提供输入并接收其输出。一个节点可以在提供输入之前开始执行一个（子）协议（例如，如果它从其他节点接收消息）。


隔离协议实例

隔离这些（子）协议实例是至关重要的，以确保与一个实例相关的消息不会在另一个实例中被重放。这在实践中通过为每个（子）协议实例关联一个唯一的字符串（会话标识符），在该（子）协议中发送或接收的任何消息上标记这个标识符，并相应地路由消息来实现。为了便于阅读，我们在协议描述中省略了这些消息标签。我们使用方括号来区分带标签的子协议实例。例如，RBC[i] 表示第i个RBC子协议实例。

我们隐含地假设各方之间的异步通信是在认证的异步信道上进行的。实际上，这样的信道可以使用TLS套接字实例化，例如，我们将在第5节中讨论。

为了区分协议内部各方发送的不同消息类型，我们使用打字机字体的标签（例如，VAL(m) 表示类型为VAL的消息m）。

4.3 从异步公共子集构建HoneyBadgerBFT

构建模块：ACS。 我们的主要构建模块是一个称为异步公共子集（ACS）的原语。构建ACS的理论可行性已在若干研究中得到证明 [9,15]。在本节中，我们将介绍ACS的正式定义，并将其作为黑盒用于构建HoneyBadgerBFT。稍后在第4.4节中，我们将展示通过组合几种过去被忽视的构建方法，我们可以高效地实例化ACS！

更正式地说，一个ACS协议满足以下属性：

• （有效性） 如果一个正确节点输出一个集合v，则|v| ≥ N−f 并且v包含至少N−2f个正确节点的输入。

• （一致性） 如果一个正确节点输出v，则每个节点都输出v。

• （完备性） 如果N−f个正确节点接收了输入，则所有正确节点都会产生输出。

构建模块：门限加密。 门限加密方案TPKE是一种加密原语，允许任何方将消息加密到一个主公钥，网络节点必须协作才能解密。一旦f+1个正确节点计算并揭示了密文的解密份额，明文就可以被恢复；直到至少一个正确节点揭示其解密份额，攻击者无法了解明文。门限加密方案提供以下接口：
