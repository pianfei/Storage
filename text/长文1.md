接“在更详细地评论这些事实时，我们将对论文的内容给出快速回顾。”

他声明，多位作者使用了不同的方法得出这些数字，但实际上这些作者无法准确地说明他们在计数什么。他认为这些计数导致相同值的事实是一种奇迹，因为使用的方法并不严格。Teichmüller随后说，为了具有意义，这些数字应该代表一个维数，并且为了讨论集合的维数（在本例中，为模量空间），必须将该集合转化为具有邻域概念的某个“空间”。4在这里，Teichmüller是第一个以如此精确的术语表述Riemann面的模量问题的人。

Teichmüller强调，不应该首先要求通过坐标系统中的数字来显式表示模量空间中的点（这种方法似乎是由Riemann的工作所暗示的），而应该更多地研究该空间的内部结构。他随后说，不仅希望模量集合R具有拓扑空间或代数多样体的结构，还希望具有解析流形的结构，即无奇点的复空间。Teichmüller说这是不可能的，因为R“包含某些奇异流形”。用现代语言来说，这对应于模量空间是一个orbifold而非流形的事实。因此，他构造了一个没有奇点的R的覆盖空间R。这个空间R后来被称为Teichmüller空间。5

Teichmüller随后简要概述了他的结果和方法，并指出他在“不久的将来”无法发布详细信息。6他宣布，他对模量问题的解决方案基于三个新引入的概念：

1) Riemann面的“拓扑决定”：这是我们今天称之为“标记”的概念。这里，一个Riemann面配备了一个固定的同胚类，从一个固定的Riemann面开始。我们注意到Teichmüller在他1939年的论文[21]中已经引入了标记。

2) Riemann面的解析族的概念：这一概念在本文中以及Teichmüller理论后续发展中都起着中心作用。它后来被多位作者重新引入，他们在研究模量空间，我们将特别提到Grothendieck。

3) “转动块坐标”的概念：这是一种修改Riemann面上简单闭曲线的正则邻域中的复结构的操作。环面的复自同构群是S^1，转动块扭曲可以被看作某种意义上的复类似于Fenchel-Nielsen扭曲的祖先。

这篇文章未吸引大量关注的原因之一可能是Teichmüller的论文被分析家而非几何学家审阅，而本文的方法是代数几何学的。另一个原因是这篇文章发表在由Bieberbach创立的短命期刊《Deutsche Mathematik》上，该期刊只有极少数的图书馆（主要在德国以外）订阅。该期刊的前两期包含了关于种族对数学影响的纳粹观点的文章。关于阅读Teichmüller论文的困难，我们可以引用Ahlfors在1954年的论文《等距映射》[2]中的话，其中他引用了Teichmüller1939年论文[21]的结果：“为了完整性，我们没有犹豫地几乎不变地重现了Teichmüller的推理。一个好的原因是Teichmüller的论文不容易获取。另一个原因是，从充满猜想的迷宫中提取Teichmüller的完整且无可辩驳的证明需要相当的努力。”

细致模量空间是一个纤维空间，其中纤维的同构类型决定了它下方的点。4 Teichmüller写道，只要R不是具有邻域概念的空间，它就不具有分析学或集合论意义上的维数。在这个背景下，“集合论”指的是拓扑学。
可能是André Weil首次提出了“Teichmüller空间”这个名称；参见Weil在其《Collected Papers》（第二卷，第546页）中的评论，Weil写道：“[...] 这促使我撰写关于曲线模量和我称之为‘Teichmüller空间’的观察。”还可以参考[13]中的历史评论。

Teichmüller同年去世，享年30岁。在这一介绍之后，Teichmüller定义了模量空间R和等价类群在该空间上的作用。他将模量问题制定为，先验上是“询问空间R的性质”的问题。然而，他说，实际上更好的是研究覆盖R而不是R本身。模量问题再次以更精确的形式给出。

Teichmüller随后引入了解析n维流形的概念，由具有解析坐标变换的坐标图定义。看起来这是该定义在数学文献中的一个早期出现。我们可以引用Remmert的话（第19页，第225页）：

很难确定第一篇显示复流形的文章。在1944年，它们出现在Teichmüller关于“可变Riemann面”的工作中（Collected Papers，第714页）；在这里，我们第一次遇到德语“komplex analytische Mannigfaltigkeit”的表达。英语“complex manifold”出现在Chern的工作中（第8页，第103页）；他只是顺便提到通过星座来定义。而在1947年，我们在Weil的文章[23]的标题中发现“variété analytique complexe”。复流形瞬间在各处绽放。

无论如何，值得注意的是，文献中首次出现的高维复流形的例子（其他不是复数域C^n，n≥2的域的例子）正是等价类的标记复流形（维数为一）的空间。7

Teichmüller随后引入了Riemann面的解析族的概念。用现代语言来说，这是一个在解析基空间B上的纤维丛M，纤维是Riemann面。从微分学的角度来看，纤维丛局部平凡（但从解析学的角度来看，由于在一个简化的乘积邻域中，两个纤维通常不同构为Riemann面）。

Riemann面的一个特别有趣的解析族是基空间B为Teichmüller空间且每个点上的纤维为代表该点自身的标记Riemann面的情况。在这种情况下，纤维丛被称为普适Teichmüller曲线，或称Teichmüller曲线。

我们注意到，Teichmüller曲线后来在数学文献中被重新引入，通常没有引用Teichmüller的论文。对Teichmüller空间的纤维丛方法被多位作者扩展和精确化，例如参见Ahlfors的[4]、Bers的[6]、[12]和Earle与Eells的[9]。在Ahlfors的1961年论文[4]和Bers的1961年论文[6]中，这个纤维丛被用来定义Teichmüller空间的复杂结构。8

7 当然，Teichmüller空间当时还不被认为是复域。后来发现了该空间嵌入到 $(\mathbb{C}^N)$的方法。

8 Ahlfors在他的论文中（第171页）说他的方法“基本上是Bers的”，Bers写道（第356页）：“Teichmüller声称高维Teichmüller空间具有‘自然’的复杂结构；第一次证明是由Ahlfors给出的，Rauch展示了如何在任何不是双曲面的点的邻域引入复分析坐标。其他证明归功于Kodaira-Spencer和Weil。”Bers在讨论解析结构的一节开头写道：“这一节和下一节的结果证实并扩展了Teichmüller在论文《可变Riemann面》中的一些断言。它们还表明，上述定义的复分析结构是自然的，并与Rauch-Ahlfors的结构相符。”我们顺便指出，Riemann面的纤维丛的切丛序列是Kodaira-Spencer关于Riemann面微小变形理论的基础[14]，该理论也提供了Teichmüller空间复杂结构的描述。Grothendieck对Teichmüller空间的研究基于对具有Riemann面作为纤维的基面的解析纤维丛的考虑（Grothendieck将其称为“亏格为g的代数曲线”），参见[12]，第7讲及以下。最后，我们注意到纤维丛方法也被用来定义解析向量丛，最自然的一个是在基空间上的每一点处取纤维面的切丛。对模量空间上纤维丛的特征类的研究导致了多项重要发展。在这方面，我们提到Mumford猜想（由Madsen解决）和Witten猜想（由Kontsevich解决）。

9 这个术语是德语“permanente Ortsuniformisierende”的英文翻译，Bers也在[6]中使用。Teichmüller曲线证明是Hodge理论中一个极其重要的对象。

Teichmüller的目标是展示Teichmüller曲线是维数为(3g - 2)的复流形。

在一般情况下，当基空间B是具有Riemann面为纤维的解析流形时，Teichmüller引入了一个他称之为永久坐标的概念，这是一个局部解析坐标系统 9，为每个纤维上的Riemann面提供一个解析参数。因此，Teichmüller得到了一个局部适用于B上点的Riemann面族的坐标t，与B的局部r维参数结合，产生了M的（r+1）维参数系统，将其视为（r+1）维复流形。他声明这样的永久坐标存在。

纤维上的Riemann面在先验条件下没有标记。Teichmüller表明可以从一个纤维的标记获得周围纤维的标记。他接着说，由于众所周知的原理，从空间B可以构造一个相对未分叉的覆盖B，B上的点的纤维是标记的Riemann面。

Teichmüller接着陈述了一个全局解析的标记（Teichmüller称之为“拓扑确定”）Riemann面族H[c]的存在性和唯一性定理，其中c遍历一个τ维复解析流形C，对于任何亏格为 g为g的标记Riemann面H，存在且仅存在一个c，使得Riemann面H与H[c]同胚，且族H[c]满足以下普适性质：如果H[p]是以B为基的任何全局解析的Riemann面族，则存在一个holomorphic映射 $(f : B \to C)$，使得族H[p]是通过f提升的族H[c]。Teichmüller声明这样的族H[c]存在，并且在本质上是唯一的。从上下文来看，用现代术语来说，本质唯一性意味着族是等价类群作用下唯一的。

复解析流形C，作为族H[c]的基空间，是我们今天称之为Teichmüller空间的对象。这个存在性和唯一性结果后来被Grothendieck重新发现，他用与Teichmüller不同的代数几何语言给出了完整的证明。Grothendieck在Cartan的研讨会上（1960-1961年）关于此主题做了一系列讲座，并将这些讲座的文字记录流传和出版。Grothendieck的陈述比Teichmüller的更一般；它用普适性质的术语表达，涉及使用Grothendieck的措辞的一个“硬化函子”P相对于离散群 $(\gamma) $，可以特别取为“Teichmüller硬化函子”，其中 $(\gamma) $是等价类群。Grothendieck的陈述是以下内容（在这个陈述中，T是Teichmüller空间）：

定理3.1：存在一个解析空间T和在T上的P代数曲线V，它们是普适的，意味着对于每个在解析空间S上的P代数曲线X，存在唯一的映 $射(g : S \to T) $，使得X（以及其P结构）与通过g提升的V/T是同构的。

Grothendieck推出以下推论（在这里 $(\gamma)$如前所述是等价类群）：

命题3.3：设X, X'是在S上的两个P曲线，分别由映射(f, f')从S到T定义。假定S是连通的且非空。那么X与X'的S同构（不考虑P结构）的集合，在自然意义上与满足 $(f' = u \circ f) $的 $(u \in \gamma) $的集合一一对应。

这是关于等价类群的刚性陈述。等价类群被自然地识别为P曲线的同构类群。
将这段关于Teichmüller曲线的存在性和唯一性（直至映射类群作用）的陈述，可以被视为系列成果中的第一个，该系列成果之后陆续获得，均关于映射类群作用的刚性。其中下一个（也可能是最著名的）是罗伊登的结果，该结果指出Teichmüller空间复结构的自同构群是扩展映射类群，参见 [20]。通用族的存在性和唯一性后来由阿尔福斯和伯斯独立构建，参见 [10] 中的历史评述。

Teichmüller认为这个定理解决了模空间问题，并借此机会更精确地阐述了这个问题：亏格为 $g$ 的解析标记曲面的所有类别的空间 R，通过将其等同于通用解析族的基空间 C，而被转化为复解析流形。这同时赋予了Teichmüller空间一个复解析结构和一个拓扑结构。 Teichmüller对此定理的证明使用了来自代数几何的工具，以及除子、主部和位的代数几何语言。他陈述了第二个定理，这个定理是第一个定理的证明所必需的，该结果关于“通过广义主部系统确定一个函数”。在这种背景下，黎曼曲面是通过函数域来研究的。黎曼曲面被视为超越次数为 1 的 C 上的域。域中的位反过来给出了曲面。

然后，Teichmüller引入了转折片的概念以及转折片的转折片坐标的概念。这是一种改变曲面复结构的方法，这种曲面按照黎曼的传统，被给定为与代数函数相关的平面的分支覆盖。解析函数由“广义主部系统”确定。Teichmüller空间的解析结构是通过改变这些函数的系数来定义的。

Teichmüller指出他的空间 R“最多由可数个连通部分组成”，并且他“认为 R 实际上是单连通的”。因此，他不确定他在本文中定义的空间 R 是否与他在 1939 年的论文 [21] 中使用拟共形理论定义的Teichmüller空间相同。值得注意的是，格罗滕迪克解决了这个问题。事实上，在引入了使用泛性质的Teichmüller空间的定义（正如我们上面回顾的那样）之后，格罗滕迪克在 ([12] 7-08) 中写道：

“同样很容易检查，如果需要的话，可以使用伯斯 [7] 的一篇论文，我们在这里公理化引入的空间（如果这个空间存在，我们将证明这个事实）与分析学家的Teichmüller空间同构。由此可见，Teichmüller空间同胚于一个球，因此是可收缩的，特别是连通的且单连通的。 自然而然地，所有层次的雅可比空间都是连通的，如同在第 5 节中作为Teichmüller空间的商空间引入的模空间 M 一样。似乎目前甚至没有模空间连通性的代数几何证明（我们可以用代数几何来解释，即相同亏格 g 的两条曲线是代数曲线族的一部分，该曲线族由连通的代数簇参数化）。

然后，Teichmüller继续研究模空间，即通过忘记标记而得到的空间。描述非常简短。（他说：“最后，我想简要提及当释放拓扑确定性时会发生什么。”）他回顾了映射类群的定义及其在标记曲面的等价类空间上的作用，他表明这种作用是真不连续的，并且他将模空间定义为Teichmüller空间在这种作用下的商空间。他考虑了他称之为 R 的奇异点；它们位于 R 的某个解析子流形上。这些点被映射类群的非平凡有限群稳定化，并且它们是模空间成为复流形的障碍。他表明，其中一些点是实质性的奇点，也就是说，模空间在这些点不是流形。 

([12] p. 7-08) [定理 3.1.— 存在一个解析空间 T，以及一个在 T 之上的 P-代数曲线 V，它们在以下意义上是通用的：对于任何在解析空间 S 之上的 P-代数曲线 X，都存在一个且只有一个从 S 到 T 的态射 g，使得 X 与 V/T 通过 g 的拉回（及其 P-结构）同构]。 格罗滕迪克似乎听说过Teichmüller的论文，但像许多其他人一样，他并没有阅读它们。尽管如此，Teichmüller在模空间问题上的工作对格罗滕迪克产生了巨大的影响，格罗滕迪克在本论文的引言中宣称，标题是：“Teichmüller空间及其变体的公理化描述”：“在这样做的时候，重新审视解析几何基础的必要性将变得显而易见。”。

似乎研究Teichmüller理论的分析学家听说过格罗滕迪克的工作，但并没有理解它。 我们可以引用阿比科夫在此处的评论，他在 1989 年在《美国数学会通报》[1] 上发表的一份关于 Nag 的书的报告中写道：“首先，代数几何学家将我们这些高贵但孤立的、具有反传统学科的实践者，置于他们强大的羽翼之下。 我们学会了提供引理的乐趣，这些引理解决了偏微分方程和积分方程以及各种其他具体的实际结果。 这些引理使如下定理成为可证明的：这个是可表示的。” 

让我们也引用阿尔福斯在 1964 年关于拟共形映射的综述 [5]（第 152 页）中谈到Teichmüller 1944 年的论文时说：“在最后一次努力中，Teichmüller用一种完全不同的方法解决了结构问题，但它太繁琐了，以至于没有人检查过所有细节，这令人怀疑。 [...]公平地说，在这一点上必须提到，代数学家也解决了模空间问题，在某种意义上甚至比分析学家更彻底。 由于语言不同，目前很难比较代数方法和分析方法，但似乎两者都有各自的优势。

([12] p. 7-10) [命题 3.3.— 令 X,X ′ 是在 S 之上的两条 P-曲线，分别由从 S 到 T 的态射 f,f ′ 定义。假设 S 是非空连通的。那么，对于基础曲线（没有 P-结构）的 S-同构 $X \sim \rightarrow X’$ 的集合，与所有满足 $f ′ = u \circ f$ 的 $u \in \gamma$ 的集合之间存在规范的双射对应]。 * 有趣的是，格罗滕迪克在陈述了他的主要定理（上面陈述的定理 3.1）之后，做出了与Teichmüller类似的评论

（[12] 第 7-10 页）：“我们将在接下来的段落中看到，配备了自同构群 γ 的解析空间 T，可以被认为是曲线亏格为 g 的 ‘模空间问题’ 的令人满意的解决方案。让我们注意到，模空间问题实际上被认为是（尽管这并没有明确说明）在模空间上定义一个复结构。 我们可以引用阿尔福斯在 1960 年的论文 [3] 中的话，他在其中写道：“[模空间]的经典问题需要一个复解析结构，而不是度量 [...] 这个问题不是一个明确的问题，并且几种表述看起来同样合理。”

--------
接“因此，我们直接反驳了流行的观点，即此类协议必然是不切实际的。”

我们对 Cachin 等人提出的最先进的异步原子广播协议进行了重大的效率改进[15]，该协议要求每个节点为每个提交的事务传输 O(N^2) 位，这大大限制了其吞吐量，除非网络规模非常小。这种低效率有两个根本原因。第一个原因是各方之间的冗余工作。然而，消除冗余的天真尝试会损害公平性，并允许有针对性的审查攻击。我们发明了一种新颖的解决方案，通过使用阈值公钥加密来防止这些攻击，从而克服了这个问题。第二个原因是使用了异步公共子集（ACS）子组件的次优实例化。我们展示了如何通过结合现有但被忽视的技术来有效地实例化 ACS：使用纠删码的高效可靠广播 [18]，以及多方计算文献中从 ACS 到可靠广播的规约 [9]。

HoneyBadgerBFT 的设计针对类似加密货币的部署场景进行了优化，其中网络带宽是稀缺资源，但计算相对充足。这使我们能够利用密码学构建块（特别是阈值公钥加密），这些构建块在经典的容错数据库环境中被认为是过于昂贵的，在经典环境中，主要目标是即使在争用情况下也能最大限度地减少响应时间。

在异步网络中，消息最终会被传递，但不做其他时序假设。与现有的弱同步协议（参数调整可能很麻烦）不同，HoneyBadgerBFT 并不关心。无论网络条件如何波动，HoneyBadgerBFT 的吞吐量始终紧密跟踪网络的可用带宽。不精确地说，只要消息最终能够送达，HoneyBadgerBFT 最终就会取得进展；此外，消息一送达，它就会取得进展。

我们正式证明了我们的 HoneyBadgerBFT 协议的安全性和活性，并通过实验表明，即使在乐观情况下，它也提供了比经典 PBFT 协议 [20] 更好的吞吐量。

实现和大规模实验。 我们提供了 HoneyBadgerBFT 的完整实现，我们将在不久的将来将其作为免费的开源软件发布。1 我们展示了来自亚马逊 AWS 部署的实验结果，该部署有 100 多个节点分布在 5 大洲。为了证明其多功能性和健壮性，我们还在 Tor 匿名中继网络上部署了 HoneyBadgerBFT，而无需更改任何参数，并展示了吞吐量和延迟结果。

在众多可能的应用中，我们重点介绍了银行、金融机构和完全去中心化加密货币倡导者所追求的两个可能的部署场景。

联盟加密货币。 比特币等去中心化加密货币的成功激发了银行和金融机构以新的视角审视其交易处理和结算基础设施。“联盟加密货币”是一个经常被引用的愿景 [24,25,47]，其中金融机构集团共同参与拜占庭协议，以允许快速和稳健地结算交易。人们热情高涨，认为这种方法将简化当今缓慢而笨拙的银行间结算基础设施。因此，一些新的开源项目旨在为此设置构建合适的 BFT 协议，例如 IBM 的开放区块链和 Hyperledger 项目 [40]。

联盟加密货币将需要一个部署在广域网上的 BFT 协议，可能涉及数百到数千个共识节点。在这种情况下，可以轻松控制注册，从而预先知道共识节点集——通常称为“许可”区块链。显然，HoneyBadgerBFT 是此类联盟加密货币中的自然选择。

适用于非许可区块链。 相比之下，比特币和以太坊等去中心化加密货币选择“非许可”区块链，其中注册对任何人开放，节点可以动态且频繁地加入和离开。为了在这种环境中实现安全性，已知的共识协议依赖于工作量证明来击败 Sybil 攻击，并在吞吐量和延迟方面付出了巨大的代价，例如，比特币每 ~10 分钟提交一次交易，即使当前区块大小最大化，其吞吐量也限制为 7 笔/秒。最近的一些工作提出了一个有希望的想法，即利用较慢的外部区块链（如比特币）或涉及基础货币本身的经济“权益证明”假设 [32,32,35,37] 来引导更快的 BFT 协议，方法是在每个不同的时期选择一个随机委员会来执行 BFT。这些方法有望实现两全其美，在开放注册、去中心化网络中实现安全性，以及与经典 BFT 协议相匹配的吞吐量和响应时间。在这里，HoneyBadgerBFT 也是一个自然的选择，因为随机选择的委员会可以在地理上是异构的。

2.1 强健的BFT协议

虽然Paxos [36]、Raft [45]和许多其他知名协议能够容忍崩溃故障，但拜占庭容错协议（BFT）自PBFT [20]以来，甚至能够容忍任意（例如，恶意）损坏的节点。许多后续协议通过乐观执行提供了改进的性能，当没有故障、客户端竞争不激烈且网络表现良好时，这些协议能够提供卓越的性能，并在其他情况下至少保证一定的进展 [2,5,33,39,51]。

一般而言，BFT系统在延迟和CPU成为瓶颈的部署场景中进行评估 [49]，因此最有效的协议通过减少轮数和最小化昂贵的加密操作来提高性能。

Clement等人 [22] 开创了一条近期的研究路线 [4,6,10,21,22,50]，主张改进最坏情况下的性能，即使这在乐观情况下会牺牲性能，也要在系统受攻击时提供服务质量保证。然而，尽管这一系列的“强健BFT”协议能够优雅地容忍被破坏的节点，它们仍然依赖于对底层网络的时间假设。我们的工作进一步推进了这种方法，即使在完全异步的网络中也能保证良好的吞吐量。

2.2 随机一致性

对于大多数任务，确定性的异步协议是不可能的 [27]。虽然绝大多数实际的BFT协议通过做出时间假设来避开这一不可能性结果，但随机性（尤其是加密技术）提供了另一条途径。事实上，我们知道有多种任务的异步BFT协议，如二元一致性（ABA）、可靠广播（RBC）等 [13,15,16]。

我们的工作与SINTRA [17] 最为相关，后者是基于Cachin等人（CKPS01）提出的异步原子广播协议的系统实现 [15]。该协议包括从原子广播（ABC）到公共子集一致性（ACS）的简化，以及从ACS到多值验证一致性（MVBA）的简化。

我们贡献的关键创新是从ABC到ACS的新颖简化，通过批处理提供更好的效率（提高了O(N)倍），同时使用门限加密来保持审查抵抗力（见第4.4节）。我们还通过从文献中精选子组件的改进实例来获得更好的效率。特别是，我们通过使用替代的ACS [9] 和高效的RBC [18] 避开了昂贵的MVBA原语，如第4.4节所述。

表1总结了HoneyBadgerBFT与其他几种原子广播协议的渐近性能。这里“通信复杂度”表示每个已提交交易的预期通信复杂度（即总传输字节数）。由于PBFT依赖于弱同步假设，因此在异步网络中可能完全无法进展。协议KS02 [34]和RC05 [46]是乐观的，回退到基于MVBA的昂贵恢复模式。如前所述，Cachin等人（CKPS01）[15] 的协议可以通过更高效的ACS构造 [9,18] 进行改进。通过我们新颖的简化，我们还获得了另一个O(N)的改进。

最后，King和Saia [30,31]最近开发了通过在稀疏图上路由通信以实现低于二次消息数量的一致性协议。然而，将这些结果扩展到异步环境仍然是一个未解决的问题。

3. 异步与弱同步网络模型之间的差距

几乎所有现代的BFT协议都依赖于时间假设（如部分或弱同步性）来保证活性。纯异步的BFT协议近年来受到的关注明显较少。考虑以下论点，如果成立，将证明这一狭窄焦点的合理性：

[X] 弱同步假设是不可避免的，因为在任何违反这些假设的网络中，即使是异步协议也会提供不可接受的性能。

在本节中，我们提出了两个反驳上述前提的反论。首先，我们展示了异步和弱同步网络模型之间的理论分离。具体来说，我们构建了一个对抗性的网络调度器，违反了PBFT的弱同步假设（并且确实导致其失败），但在这种情况下，任何纯异步协议（如HoneyBadgerBFT）都能取得良好的进展。其次，我们做出了一个实际观察：即使它们的假设得到满足，弱同步协议在网络分区恢复后仍然恢复缓慢，而异步协议只要消息被传递就会立即进展。

3.1 多种形式的时间假设

在继续之前，我们回顾各种标准的时间假设形式。在异步网络中，对手可以以任何顺序和任何时间传递消息，但仍然必须最终传递在正确节点之间发送的每条消息。异步网络中的节点实际上不需要“实时时钟”，只能基于它们接收消息的顺序采取行动。

著名的FLP [27] 结果排除了原子广播和许多其他任务的确定性异步协议的可能性。因此，确定性协议必须做出一些更强的时间假设。一种方便（但非常强）的网络假设是同步性：∆-同步网络保证每条发送的消息在最多∆的延迟后被传递（其中∆是真实时间的度量）。

较弱的时间假设有几种形式。在未知∆模型中，协议无法将延迟界限用作参数。或者，在最终同步模型中，消息延迟界限∆仅在某些（未知的）时刻之后得到保证，这个时刻被称为“全局稳定时间”。总体而言，这两种模型被称为部分同步 [26]。另一种变化是弱同步 [26]，其中延迟界限是时变的，但最终不会增长得超过时间的多项式函数 [20]。

在可行性方面，上述是等价的——在一种设置中成功的协议可以系统地适应另一种设置。然而，在具体性能方面，调整弱同步意味着逐渐增加超时参数（例如，通过“指数回退”策略）。如我们稍后所示，这在从瞬时网络分区中恢复时会导致延迟。

协议通常以超时事件的形式表现出这些假设。例如，如果各方检测到在某个时间间隔内没有进展，则采取纠正措施，如选举新领导者。异步协议不依赖于计时器，只要消息被传递，就会继续进展，无论实际的时钟时间如何。

计算异步网络中的轮数

虽然最终交付的保证与“实时时间”的概念是分离的，但仍然希望对异步协议的运行时间进行表征。标准的方法（例如，Canetti和Rabin [19] 解释的方式）是让对手为每条消息分配一个虚拟的轮数，条件是每条正确节点之间的(r−1)-消息必须在发送任何(r+1)-消息之前被传递。

3.2 弱同步性失效时

我们现在继续描述为什么在网络条件具有对抗性（或不可预测）的情况下，弱同步BFT协议可能会失败（或遭受性能下降）。这解释了为什么这些协议不适合第1节中描述的面向加密货币的应用场景。

阻碍PBFT的网络调度器

我们使用Practical Byzantine Fault Tolerance (PBFT) [20]，经典的基于领导者的BFT协议，作为一个代表性的例子来描述对抗性的网络调度器如何导致一类基于领导者的BFT协议 [4,6,10,22,33,50] 停滞不前。

在任何给定时间，指定的领导者负责提出下一批交易。如果没有进展，可能是因为领导者故障或网络停滞，节点们将尝试选举新的领导者。PBFT协议关键依赖于弱同步网络来保证活性。我们构建了一个对抗性调度器，违反了这一假设，并确实阻止PBFT取得任何进展，但HoneyBadgerBFT（实际上任何异步协议）在这种情况下表现良好。基于时间假设的协议在这些假设被违反时失败并不令人惊讶；然而，展示一个明确的攻击有助于激励我们异步构建的动机。

我们的调度器背后的直觉很简单。首先，我们假设一个单一节点已经崩溃。然后，当一个正确节点是领导者时，网络会延迟消息，阻止进展并导致轮转顺序中的下一个节点成为新的领导者。当崩溃的节点轮到成为领导者时，调度器立即修复网络分区，并在诚实节点之间迅速传递消息；然而，由于领导者已经崩溃，这里也没有进展。

这种攻击违反了弱同步假设，因为它必须在每个周期中延迟消息越来越长，因为PBFT在每次领导者选举失败后都会扩大其超时间隔。另一方面，它也提供了越来越长的同步期。然而，由于这些同步期发生在不方便的时间，PBFT无法利用它们。展望未来，HoneyBadgerBFT，实际上任何异步协议，都能在这些偶发的同步期内取得进展。

为了确认我们的分析，我们将这个恶意调度器实现为一个代理，拦截并延迟所有视图变更消息到新领导者，并在一个1200行的PBFT Python实现上进行了测试。我们观察到的结果和消息日志与上述分析一致；我们的副本陷入了一个永不成功的视图变更请求循环。在附录A中，我们对PBFT进行了完整的描述，并解释了它在这种攻击下的行为。

从网络分区中缓慢恢复

即使弱同步假设最终得到满足，依赖于它的协议在从瞬时网络分区中恢复时也可能会很慢。考虑以下场景，这只是上述攻击的一个有限前缀：一个节点崩溃，网络暂时分区持续2D∆。我们的调度器在崩溃节点轮到成为领导者时恰好修复网络分区。由于此时的超时间隔现在是2D+1∆，即使在此间隔内网络是同步的，协议也必须等待另一个2D+1∆的间隔才能开始选举新的领导者。

健壮性与响应性的权衡

上述观察到的行为并非PBFT特有，而是依赖于超时来应对崩溃的协议所固有的基本特性。无论协议的变体如何，实践者都必须根据某些权衡来调整他们的超时策略。在一个极端（最终同步性），实践者对网络延迟∆做出具体估计。如果估计值太低，系统可能根本不会取得进展；如果太高，则无法利用可用带宽。在另一个极端（弱同步性），实践者避免指定任何绝对延迟，但仍必须选择一个“增益”，这影响系统跟踪变化条件的速度。异步协议避免了调整这些参数的需要。

4. HoneyBadgerBFT协议

在本节中，我们介绍HoneyBadgerBFT，这是第一个在异步环境中实现最优渐近效率的异步原子广播协议。

4.1 问题定义：原子广播

我们首先定义我们的网络模型和原子广播问题。我们的设置涉及一个由N个指定节点组成的网络，这些节点具有不同的知名身份（P0到PN−1）。这些节点接收交易作为输入，目标是就这些交易的顺序达成共同的一致意见。我们的模型特别匹配“许可区块链”的部署场景，在这种场景中，交易可以由任意客户端提交，但负责执行协议的节点是固定的。

原子广播原语允许我们抽象出任何应用特定的细节，例如如何解释交易（例如，为了防止重放攻击，应用可能定义一个交易包括签名和序列号）。就我们的目的而言，交易只是唯一的字符串。实际上，客户端会生成交易并将其发送给所有节点，并在收集到多数节点的签名后将其视为已提交。为了简化我们的表述，我们不显式地建模客户端，而是假设交易由对手选择并作为输入提供给节点。同样，一旦节点输出交易，交易就被视为已提交。

我们的系统模型做出以下假设：

• （纯异步网络） 我们假设每对节点之间连接着一个可靠的认证点对点信道，不会丢失消息。交付计划完全由对手决定，但每条在正确节点之间发送的消息最终必须被传递。我们将关注基于异步轮数（如第2节所述）来表征协议的运行时间。由于网络可能以任意延迟排队消息，我们还假设节点具有无限缓冲区，并能够处理它们接收的所有消息。

• （静态拜占庭故障） 对手可以完全控制最多f个故障节点，其中f是协议参数。注意，对于这种设置中的广播协议，3f +1 ≤ N（我们的协议实现了这一点）是下限。

• （可信设置） 为了便于表述，我们假设节点可以在初始的协议特定设置阶段与可信的分发方互动，我们将使用这一阶段来建立公钥和秘密共享。注意，在实际部署中，如果没有实际的可信方，那么可以改用分布式密钥生成协议（参见Boldyreva [11]）。我们所知的所有分布式密钥生成协议都依赖于时间假设；幸运的是，这些假设只需在设置期间成立。

2. 可靠信道可以在不可靠信道上模拟

通过重新发送传输，可以在不可靠信道上模拟可靠信道，但以牺牲一些效率为代价。

定义1。 一个原子广播协议必须满足以下属性，这些属性应在异步网络中并且面对任意对手时，以高概率（作为安全参数λ的函数1−negl(λ)）成立：

• （一致性） 如果任何正确节点输出一个交易tx，则每个正确节点都输出tx。

• （全序） 如果一个正确节点已经输出了交易序列<tx0, tx1, ..., txj>，另一个正确节点已经输出了交易序列<tx0', tx1', ..., tx'_j'>，那么对于i ≤ min(j, j')，有txi = txi'。

• （审查抵抗力） 如果一个交易tx被输入到N−f个正确节点，那么最终每个正确节点都会输出它。

审查抵抗力属性是一种活性属性，防止对手阻止甚至单个交易的提交。这个属性在其他名字下也被提及，例如Cachin等人 [15]称之为“公平性”，但我们更喜欢这个更具描述性的短语。

性能指标。 我们主要关注分析我们的原子广播协议的效率和交易延迟。

• （效率） 假设每个诚实节点的输入缓冲区足够满，即Ω(poly(N, λ))。那么效率是每个节点在所有已提交交易上的预期通信成本的摊销值。

由于每个节点必须输出每个交易，O(1)的效率（我们的协议实现了这一点）在渐近上是最优的。上述效率定义假设网络负载，反映了我们的主要目标：在充分利用网络可用带宽的同时维持高吞吐量。由于我们通过批处理实现了良好的吞吐量，我们的系统在需求低迷期间，当交易不频繁到达时，每个已提交交易使用更多的带宽。如果我们的目标是最小化成本（例如，基于用量的计费），则无需此限定的更强定义将是适当的。

实际上，网络链接具有有限的容量，如果提交的交易超过网络可处理的量，确认时间的保证在一般情况下无法成立。因此，我们下面将交易延迟相对于在问题交易之前输入的交易数量进行定义。有限的交易延迟意味着审查抵抗力。

• （交易延迟） 假设对手将一个交易tx作为输入传递给N−f个正确节点。设T为“积压”，即任何正确节点之前输入的总交易数量与已提交交易数量之间的差异。那么交易延迟是在tx被每个正确节点输出之前的异步轮数的预期值，作为T的函数。

4.2 概述与直觉

在HoneyBadgerBFT中，节点接收交易作为输入并将其存储在（无限的）缓冲区中。协议在历元中进行，每个历元结束后，一批新的交易被追加到已提交的日志中。在每个历元开始时，节点选择其缓冲区中的一部分交易子集（通过我们稍后将定义的策略），并将其作为输入提供给一个随机一致性协议的实例。在一致性协议结束时，选择该历元的最终交易集。

在高层次上，我们的方法类似于现有的异步原子广播协议，特别是Cachin等人 [15]，这是一个大规模交易处理系统（SINTRA）的基础。如我们一样，Cachin的协议围绕异步公共子集（ACS）原语展开。粗略地说，ACS原语允许每个节点提出一个值，并保证每个节点输出一个包含至少N−2f个正确节点输入值的共同向量。从这个原语构建原子广播是微不足道的——每个节点只需从其队列前端提出一部分交易，并输出在同意的向量中的元素的并集。

然而，有两个重要的挑战。

挑战1：实现审查抵抗力。 ACS的成本直接取决于每个节点提出的交易集的大小。由于输出向量包含至少N−f个这样的集，因此通过确保节点提出的交易集大多不重叠，从而以相同的成本在一个批次中提交更多独特的交易，可以提高整体效率。因此，我们的协议中的每个节点不是简单地从其缓冲区中选择第一个元素，而是提出一个随机选择的样本，使得每个交易平均只被一个节点提出。

然而，若天真地实施这一优化，将会破坏审查抵抗力，因为ACS原语允许对手选择最终包含哪些节点的提案。对手可以选择性地审查交易，排除提出它的节点。我们通过使用门限加密避免了这一陷阱，这防止了对手在达成一致之前了解哪些节点提出了哪些交易。完整的协议将在第4.3节中描述。

挑战2：实际吞吐量。 尽管理论上已知异步ACS和原子广播是可行的 [9,15,17]，它们的实际性能尚不明朗。据我们所知，唯一实施ACS的其他工作是Cachin和Portiz [17]，他们展示了在广域网络上可以达到0.4 tx/sec的吞吐量。因此，一个有趣的问题是，这些协议是否能在实际中达到高吞吐量。

在本文中，我们展示了通过仔细选择一系列子组件，我们可以高效地实例化ACS并在渐近和实际中达到更高的吞吐量。值得注意的是，我们将ACS的渐近成本（每节点）从O(N²)（如Cachin等人 [15,17]）改进为O(1)。由于我们选择的组件尚未被一起呈现（据我们所知），我们在第4.4节中提供了整个构建的自包含描述。

模块化协议组合

我们现在准备正式展示我们的构建。在此之前，我们对我们的展示风格做出一项说明。我们以模块化的风格定义我们的协议，其中每个协议可能运行多个其他（子）协议的实例。外部协议可以向子协议提供输入并接收其输出。一个节点可以在提供输入之前开始执行一个（子）协议（例如，如果它从其他节点接收消息）。


隔离协议实例

隔离这些（子）协议实例是至关重要的，以确保与一个实例相关的消息不会在另一个实例中被重放。这在实践中通过为每个（子）协议实例关联一个唯一的字符串（会话标识符），在该（子）协议中发送或接收的任何消息上标记这个标识符，并相应地路由消息来实现。为了便于阅读，我们在协议描述中省略了这些消息标签。我们使用方括号来区分带标签的子协议实例。例如，RBC[i] 表示第i个RBC子协议实例。

我们隐含地假设各方之间的异步通信是在认证的异步信道上进行的。实际上，这样的信道可以使用TLS套接字实例化，例如，我们将在第5节中讨论。

为了区分协议内部各方发送的不同消息类型，我们使用打字机字体的标签（例如，VAL(m) 表示类型为VAL的消息m）。

4.3 从异步公共子集构建HoneyBadgerBFT

构建模块：ACS。 我们的主要构建模块是一个称为异步公共子集（ACS）的原语。构建ACS的理论可行性已在若干研究中得到证明 [9,15]。在本节中，我们将介绍ACS的正式定义，并将其作为黑盒用于构建HoneyBadgerBFT。稍后在第4.4节中，我们将展示通过组合几种过去被忽视的构建方法，我们可以高效地实例化ACS！

更正式地说，一个ACS协议满足以下属性：

• （有效性） 如果一个正确节点输出一个集合v，则|v| ≥ N−f 并且v包含至少N−2f个正确节点的输入。

• （一致性） 如果一个正确节点输出v，则每个节点都输出v。

• （完备性） 如果N−f个正确节点接收了输入，则所有正确节点都会产生输出。

构建模块：门限加密。 门限加密方案TPKE是一种加密原语，允许任何方将消息加密到一个主公钥，网络节点必须协作才能解密。一旦f+1个正确节点计算并揭示了密文的解密份额，明文就可以被恢复；直到至少一个正确节点揭示其解密份额，攻击者无法了解明文。门限加密方案提供以下接口：

• TPKE.Setup(1^λ) → PK, {SK_i} 生成一个公钥PK，以及每个方的密钥SK_i。

• TPKE.Enc(PK, m) → C 加密消息m。

• TPKE.DecShare(SK_i, C) → σ_i 生成密文的第i^th个解密份额（如果C格式错误，则生成⊥）。

• TPKE.Dec(PK, C, {i, σ_i}) → m 结合至少f+1个方的解密份额{ i, σ_i }来获得明文m（或者，如果C包含无效份额，则识别出无效份额）。

在我们的具体实例中，我们使用Baek和Zheng [7]的门限加密方案。该方案也是健壮的（符合我们的协议需求），这意味着即使对于对手生成的密文C，最多只能恢复一个明文（除了⊥以外）。注意，我们假设TPKE.Dec在输入中有效地识别无效的解密份额。最后，该方案满足明显的正确性属性，以及IND-CPA游戏的门限版本。

```
算法 HoneyBadgerBFT（针对节点 P_i）

令 B = Ω(λN² logN) 作为批处理大小参数。
令 PK 为从 TPKE.Setup（由协调者执行）接收到的公钥，并令 SK_i 为 P_i 的私钥。
令 buf := [] 为一个输入交易的先进先出队列。
按连续的纪元编号 r 进行操作：

// 步骤 1：随机选择和加密
令 proposed 为从 buf 的前 B 个元素中随机选择的 ⌊B/N⌋ 个交易。
加密 x := TPKE.Enc(PK, proposed)

// 步骤 2：对密文达成一致
将 x 作为输入传递给 ACS[r] // 参见图 4
从 ACS[r] 接收 {v_j}_{j∈S}，其中 S ⊂ [1..N]

// 步骤 3：解密
对于每个 j ∈ S：
令 e_j := TPKE.DecShare(SK_i, v_j)
广播 DEC(r, j, i, e_j)
等待接收至少 f + 1 条形式为 DEC(r, j, k, e_{j,k}) 的消息
解码 y_j := TPKE.Dec(PK, {(k, e_{j,k})})
令 block_r := sorted(∪_{j∈S} {y_j})，使得 block_r 按规范顺序排序（例如，按字典序）
设置 buf := buf - block_r
```

从ACS构建原子广播

我们现在更详细地描述我们的原子广播协议，该协议在图1中定义。如前所述，该协议围绕ACS的一个实例展开。

为了获得可扩展的效率，我们选择了批处理策略。设B为批大小，每个历元将提交Ω(B)笔交易。每个节点从其队列中提出B/N笔交易。为了确保节点提出的交易大多不重叠，我们随机从每个队列的前B笔中选择这些交易。

如第4.4节所述，我们的ACS实例化的总通信成本为O(N²|v| + λN³logN)，其中|v|限定了任何节点的输入大小。因此，我们选择批大小B = Ω(λN²logN)，以便每个节点的贡献（B/N）能够吸收这个附加开销。

为了防止对手影响结果，我们使用了门限加密方案，如下所述。简而言之，每个节点选择一组交易，然后对其进行加密。每个节点然后将加密结果作为输入传递给ACS子程序。因此，ACS的输出是密文的向量。一旦ACS完成，密文就会被解密。这保证了在对手了解每个节点提出的提案内容之前，交易集已经完全确定。这保证了一旦交易在足够多的正确节点的队列前端，一旦交易被确定无法被对手选择性地阻止。

4.4 高效实例化ACS

Cachin等人提出了一个我们称为CKPS01的协议，该协议（隐式地）将ACS简化为多值验证拜占庭一致性（MVBA） [15]。粗略地说，MVBA允许节点提出满足谓词的值，其中一个最终被选中。简化很简单：验证谓词规定输出必须是至少N−f个方签名输入的向量。不幸的是，MVBA原语的协议成为了瓶颈，因为我们所知道的唯一构造需要O(N³|v|)的开销。

我们通过使用一种完全绕过MVBA的ACS替代实例化来避免这一瓶颈。我们使用的实例化来自Ben-Or等人 [9]，在我们看来，这种实例化有些被忽视。事实上，它早于CKPS01 [15]，最初是为一种基本无关的目的开发的（作为实现高效异步多方计算的工具 [9]）。该协议是将ACS简化为可靠广播（RBC）和异步二元拜占庭一致性（ABA）的一个简化。直到最近，我们才知道这些子组件的高效构造，我们稍后会解释。

在高层次上，ACS协议分为两个主要阶段。在第一阶段，每个节点Pi使用RBC将其提出的值传播给其他节点，然后使用ABA决定一个位向量，指示哪些RBC已经成功完成。

我们现在简要解释RBC和ABA的构造，然后再详细解释Ben-Or协议。

通信最优的可靠广播

异步可靠广播通道满足以下属性：

• （一致性） 如果任何两个正确节点传递v和v'，则v = v'。

• （全性） 如果任何正确节点传递v，则所有正确节点都传递v。

• （有效性） 如果发送者是正确的并且输入v，则所有正确节点都传递v。

虽然Bracha的经典可靠广播协议需要O(N²|v|)比特的总通信量才能广播一个大小为|v|的消息，但Cachin和Tessaro [18] 观察到，纠删编码可以将此成本减少到仅O(N|v| + λN²logN)，即使在最坏情况下也是如此。这对于大消息（即，当|v| >> λNlogN）来说是一个显著的改进，这也（回到第4.3节）指导了我们对批大小的选择。此处使用纠删编码仅引入了一个小的常数倍开销，等于 $\frac{N}{N−2f} < 3$

如果发送者是正确的，总运行时间为三个（异步）轮；在任何情况下，从第一个正确节点输出一个值到最后一个输出一个值之间最多经过两个轮。图2展示了可靠广播算法。

```
算法 RBC（针对参与方 P_i，发件方为 P_Sender）

当输入(v)时（如果 P_i = P_Sender）：
令 {s_j}_{j∈[N]} 是将 (N−2f, N) 擦除编码方案应用于 v 后得到的块。
令 h 为基于 {s_j} 计算的默克尔树根。
向每个参与方 P_j 发送 VAL(h, b_j, s_j)，其中 b_j 是第 j 个默克尔树分支。
当从 P_Sender 接收到 VAL(h, b_i, s_i) 时，
广播 ECHO(h, b_i, s_i)
当从参与方 P_j 接收到 ECHO(h, b_j, s_j) 时，
检查 b_j 是否是根为 h 且叶为 s_j 的有效默克尔分支，否则丢弃。
当从 N−f 个不同参与方接收到有效的 ECHO(h,·,·) 消息时，
从接收到的任何 N−2f 个叶中插值 {s'_j}
重新计算默克尔根 h'，如果 h' ≠ h，则中止
如果尚未发送 READY(h)，则广播 READY(h)
当接收到 f+1 条匹配的 READY(h) 消息时，如果尚未发送 READY，则广播 READY(h)
当接收到 2f+1 条匹配的 READY(h) 消息时，等待 N−2f 条 ECHO 消息，然后解码 v
```

图 2：可靠广播算法，改编自 Bracha 的广播算法 [13]，并采用擦除码以提高效率 [18]。

二元共识

二元共识是一种标准原语，允许节点就单个比特的值达成一致。更正式地说，二元共识保证三个属性：

（一致性） 如果任何正确节点输出比特 b，那么每个正确节点都输出 b。

（终止性） 如果所有正确节点都接收到输入，那么每个正确节点都会输出一个比特。

（有效性） 如果任何正确节点输出 b，那么至少有一个正确节点接收到 b 作为输入。

有效性属性暗示了一致性：如果所有正确节点接收到相同的输入值 b，那么 b 必须是决定的值。另一方面，如果在任何时候两个节点接收到不同的输入，那么敌手可能会在其余节点接收输入之前迫使决策为任意值。

我们使用 Moustefaoui 等人 [42] 基于密码学公共硬币的协议来实现这个原语。我们将这个实现的解释推迟到附录中。其预期运行时间是 O(1)，实际上在 O(k) 轮内完成的概率为 1−2⁻ᵏ。每个节点的通信复杂度是 O(Nλ)，这主要是由于公共硬币中使用的阈值密码学。

就提议值的子集达成一致

将上述部分组合在一起，我们使用 Ben-Or 等人 [9] 的协议来同意一个包含至少 N−f 个节点的全部提议的值集合。

从高层次来看，这个协议主要分为两个阶段。在第一阶段，每个节点 P_i 使用可靠广播将其提议值传播给其他节点。在第二阶段，使用 N 个并发的二元拜占庭共识实例来同意一个比特向量 {b_j}_{j∈[1..N]}，其中 b_j = 1 表示 P'_j 的提议值包含在最终集合中。

实际上，上述简单描述掩盖了一个微妙的挑战，Ben-Or 提供了一个巧妙的解决方案。

一个天真的实现尝试是让每个节点等待前 (N−f) 个广播完成，然后为对应的二元共识实例提议 1，为其他所有实例提议 0。然而，正确节点可能会观察到广播以不同的顺序完成。由于二元共识只保证如果所有正确节点一致提议 1 时输出为 1，因此结果比特向量可能为空。

为避免这个问题，节点在确定最终向量至少有 N−f 个比特被设置之前，不提议 0。

为了提供这个协议流程的一些直觉，我们在图 3 中叙述了几种可能的场景。Ben-Or 等人 [9] 的算法在图 4 中给出。预期运行时间是 O(logN)，因为它必须等待所有二元共识实例完成。

当使用上述描述的可靠广播和二元共识构造进行实例化时，总通信复杂度为 O(N²|v| + λN³logN)，假设 |v| 是任何节点输入的最大大小。

![图3](../pic/rbctu3.JPG)

图 3：（ACS 执行的示例说明） 我们的协议的每次执行都涉及运行 N 个并发的可靠广播（RBC）实例，以及 N 个拜占庭协议（BA）实例，而拜占庭协议又使用期望常数数量的公共硬币。我们从节点 0 的角度说明了这些实例如何进行的几种可能示例。(a) 在通常情况下，节点 0 从索引为 1 的可靠广播接收值 V1（节点 1 提出的值）。因此，节点 0 向 BA1 提供输入“Yes”，BA1 输出“Yes”。(b) RBC2 花费太长时间才能完成，并且节点 0 已经收到 (N - f) 个“Yes”输出，因此它对 BA2 投“No”。但是，其他节点已经看到 RBC2 成功完成，因此 BA2 的结果是“Yes”，并且节点 0 必须等待 V2。(c) BA3 在 RBC3 完成之前以“No”结束。